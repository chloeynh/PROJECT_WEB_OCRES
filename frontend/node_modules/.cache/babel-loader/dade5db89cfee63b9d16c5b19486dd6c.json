{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateServiceStub = void 0;\n/* global window */\n\n/* global AbortController */\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nconst abort_controller_1 = require(\"abort-controller\");\n\nconst featureDetection_1 = require(\"./featureDetection\");\n\nfunction generateServiceStub(rpcs, protocol, servicePath, servicePort, authClient, requestEncoder, responseDecoder) {\n  const fetch = featureDetection_1.hasWindowFetch() ? window.fetch : node_fetch_1.default;\n  const serviceStub = {};\n\n  for (const _ref of Object.entries(rpcs)) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    const rpcName = _ref2[0];\n    const rpc = _ref2[1];\n\n    serviceStub[rpcName] = (request, options, _metadata, callback) => {\n      // We cannot use async-await in this function because we need to return the canceller object as soon as possible.\n      // Using plain old promises instead.\n      const cancelController = featureDetection_1.hasAbortController() ? new AbortController() : new abort_controller_1.AbortController();\n      const cancelSignal = cancelController.signal;\n      let cancelRequested = false;\n      const fetchParameters = requestEncoder(rpc, protocol, servicePath, servicePort, request);\n      const url = fetchParameters.url;\n      const headers = fetchParameters.headers;\n\n      for (const key of Object.keys(options)) {\n        headers[key] = options[key][0];\n      }\n\n      authClient.getRequestHeaders().then(authHeader => {\n        const fetchRequest = {\n          headers: { ...authHeader,\n            ...headers\n          },\n          body: fetchParameters.body,\n          method: fetchParameters.method,\n          signal: cancelSignal\n        };\n\n        if (fetchParameters.method === 'get' || fetchParameters.method === 'delete') {\n          delete fetchRequest['body'];\n        }\n\n        return fetch(url, fetchRequest);\n      }).then(response => {\n        return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]);\n      }).then(([ok, buffer]) => {\n        const response = responseDecoder(rpc, ok, buffer);\n        callback(null, response);\n      }).catch(err => {\n        if (!cancelRequested || err.name !== 'AbortError') {\n          callback(err);\n        }\n      });\n      return {\n        cancel: () => {\n          cancelRequested = true;\n          cancelController.abort();\n        }\n      };\n    };\n  }\n\n  return serviceStub;\n}\n\nexports.generateServiceStub = generateServiceStub;","map":null,"metadata":{},"sourceType":"script"}