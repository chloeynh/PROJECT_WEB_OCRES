{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.teenyRequest = exports.RequestError = void 0;\n\nconst node_fetch_1 = require(\"node-fetch\");\n\nconst stream_1 = require(\"stream\");\n\nconst uuid = require(\"uuid\");\n\nconst agents_1 = require(\"./agents\");\n\nconst TeenyStatistics_1 = require(\"./TeenyStatistics\"); // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\nconst streamEvents = require('stream-events');\n\nclass RequestError extends Error {}\n\nexports.RequestError = RequestError;\n/**\n * Convert options from Request to Fetch format\n * @private\n * @param reqOpts Request options\n */\n\nfunction requestToFetchOptions(reqOpts) {\n  const options = {\n    method: reqOpts.method || 'GET',\n    ...(reqOpts.timeout && {\n      timeout: reqOpts.timeout\n    }),\n    ...(typeof reqOpts.gzip === 'boolean' && {\n      compress: reqOpts.gzip\n    })\n  };\n\n  if (typeof reqOpts.json === 'object') {\n    // Add Content-type: application/json header\n    reqOpts.headers = reqOpts.headers || {};\n    reqOpts.headers['Content-Type'] = 'application/json'; // Set body to JSON representation of value\n\n    options.body = JSON.stringify(reqOpts.json);\n  } else {\n    if (Buffer.isBuffer(reqOpts.body)) {\n      options.body = reqOpts.body;\n    } else if (typeof reqOpts.body !== 'string') {\n      options.body = JSON.stringify(reqOpts.body);\n    } else {\n      options.body = reqOpts.body;\n    }\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  options.headers = reqOpts.headers;\n  let uri = reqOpts.uri || reqOpts.url;\n\n  if (!uri) {\n    throw new Error('Missing uri or url in reqOpts.');\n  }\n\n  if (reqOpts.useQuerystring === true || typeof reqOpts.qs === 'object') {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const qs = require('querystring');\n\n    const params = qs.stringify(reqOpts.qs);\n    uri = uri + '?' + params;\n  }\n\n  options.agent = agents_1.getAgent(uri, reqOpts);\n  return {\n    uri,\n    options\n  };\n}\n/**\n * Convert a response from `fetch` to `request` format.\n * @private\n * @param opts The `request` options used to create the request.\n * @param res The Fetch response\n * @returns A `request` response object\n */\n\n\nfunction fetchToRequestResponse(opts, res) {\n  const request = {};\n  request.agent = opts.agent || false;\n  request.headers = opts.headers || {};\n  request.href = res.url; // headers need to be converted from a map to an obj\n\n  const resHeaders = {};\n  res.headers.forEach((value, key) => resHeaders[key] = value);\n  const response = Object.assign(res.body, {\n    statusCode: res.status,\n    statusMessage: res.statusText,\n    request,\n    body: res.body,\n    headers: resHeaders,\n    toJSON: () => ({\n      headers: resHeaders\n    })\n  });\n  return response;\n}\n/**\n * Create POST body from two parts as multipart/related content-type\n * @private\n * @param boundary\n * @param multipart\n */\n\n\nfunction createMultipartStream(boundary, multipart) {\n  const finale = \"--\".concat(boundary, \"--\");\n  const stream = new stream_1.PassThrough();\n\n  for (const part of multipart) {\n    const preamble = \"--\".concat(boundary, \"\\r\\nContent-Type: \").concat(part['Content-Type'], \"\\r\\n\\r\\n\");\n    stream.write(preamble);\n\n    if (typeof part.body === 'string') {\n      stream.write(part.body);\n      stream.write('\\r\\n');\n    } else {\n      part.body.pipe(stream, {\n        end: false\n      });\n      part.body.on('end', () => {\n        stream.write('\\r\\n');\n        stream.write(finale);\n        stream.end();\n      });\n    }\n  }\n\n  return stream;\n}\n\nfunction teenyRequest(reqOpts, callback) {\n  const _requestToFetchOption = requestToFetchOptions(reqOpts),\n        uri = _requestToFetchOption.uri,\n        options = _requestToFetchOption.options;\n\n  const multipart = reqOpts.multipart;\n\n  if (reqOpts.multipart && multipart.length === 2) {\n    if (!callback) {\n      // TODO: add support for multipart uploads through streaming\n      throw new Error('Multipart without callback is not implemented.');\n    }\n\n    const boundary = uuid.v4();\n    options.headers['Content-Type'] = \"multipart/related; boundary=\".concat(boundary);\n    options.body = createMultipartStream(boundary, multipart); // Multipart upload\n\n    teenyRequest.stats.requestStarting();\n    node_fetch_1.default(uri, options).then(res => {\n      teenyRequest.stats.requestFinished();\n      const header = res.headers.get('content-type');\n      const response = fetchToRequestResponse(options, res);\n      const body = response.body;\n\n      if (header === 'application/json' || header === 'application/json; charset=utf-8') {\n        res.json().then(json => {\n          response.body = json;\n          callback(null, response, json);\n        }, err => {\n          callback(err, response, body);\n        });\n        return;\n      }\n\n      res.text().then(text => {\n        response.body = text;\n        callback(null, response, text);\n      }, err => {\n        callback(err, response, body);\n      });\n    }, err => {\n      teenyRequest.stats.requestFinished();\n      callback(err, null, null);\n    });\n    return;\n  }\n\n  if (callback === undefined) {\n    // Stream mode\n    const requestStream = streamEvents(new stream_1.PassThrough()); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let responseStream;\n    requestStream.once('reading', () => {\n      if (responseStream) {\n        responseStream.pipe(requestStream);\n      } else {\n        requestStream.once('response', () => {\n          responseStream.pipe(requestStream);\n        });\n      }\n    });\n    options.compress = false;\n    teenyRequest.stats.requestStarting();\n    node_fetch_1.default(uri, options).then(res => {\n      teenyRequest.stats.requestFinished();\n      responseStream = res.body;\n      responseStream.on('error', err => {\n        requestStream.emit('error', err);\n      });\n      const response = fetchToRequestResponse(options, res);\n      requestStream.emit('response', response);\n    }, err => {\n      teenyRequest.stats.requestFinished();\n      requestStream.emit('error', err);\n    }); // fetch doesn't supply the raw HTTP stream, instead it\n    // returns a PassThrough piped from the HTTP response\n    // stream.\n\n    return requestStream;\n  } // GET or POST with callback\n\n\n  teenyRequest.stats.requestStarting();\n  node_fetch_1.default(uri, options).then(res => {\n    teenyRequest.stats.requestFinished();\n    const header = res.headers.get('content-type');\n    const response = fetchToRequestResponse(options, res);\n    const body = response.body;\n\n    if (header === 'application/json' || header === 'application/json; charset=utf-8') {\n      if (response.statusCode === 204) {\n        // Probably a DELETE\n        callback(null, response, body);\n        return;\n      }\n\n      res.json().then(json => {\n        response.body = json;\n        callback(null, response, json);\n      }, err => {\n        callback(err, response, body);\n      });\n      return;\n    }\n\n    res.text().then(text => {\n      const response = fetchToRequestResponse(options, res);\n      response.body = text;\n      callback(null, response, text);\n    }, err => {\n      callback(err, response, body);\n    });\n  }, err => {\n    teenyRequest.stats.requestFinished();\n    callback(err, null, null);\n  });\n  return;\n}\n\nexports.teenyRequest = teenyRequest;\n\nteenyRequest.defaults = defaults => {\n  return (reqOpts, callback) => {\n    const opts = { ...defaults,\n      ...reqOpts\n    };\n\n    if (callback === undefined) {\n      return teenyRequest(opts);\n    }\n\n    teenyRequest(opts, callback);\n  };\n};\n/**\n * Single instance of an interface for keeping track of things.\n */\n\n\nteenyRequest.stats = new TeenyStatistics_1.TeenyStatistics();\n\nteenyRequest.resetStats = () => {\n  teenyRequest.stats = new TeenyStatistics_1.TeenyStatistics(teenyRequest.stats.getOptions());\n};","map":null,"metadata":{},"sourceType":"script"}