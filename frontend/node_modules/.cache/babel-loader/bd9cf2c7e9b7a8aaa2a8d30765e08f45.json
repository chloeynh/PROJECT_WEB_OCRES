{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _inherits = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _wrapNativeSuper = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nfunction _wrapRegExp(re, groups) { _wrapRegExp = function (re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _wrapNativeSuper(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _inherits(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === \"string\") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) { return \"$\" + groups[name]; })); } else if (typeof substitution === \"function\") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (typeof args[args.length - 1] !== \"object\") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseExternalAccountClient = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;\n\nconst stream = require(\"stream\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\n\n\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\n\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The default OAuth scope to request when none is provided. */\n\nconst DEFAULT_OAUTH_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\n/** The google apis domain pattern. */\n\nconst GOOGLE_APIS_DOMAIN_PATTERN = '\\\\.googleapis\\\\.com$';\n/** The variable portion pattern in a Google APIs domain. */\n\nconst VARIABLE_PORTION_PATTERN = '[^\\\\.\\\\s\\\\/\\\\\\\\]+';\n/**\n * Offset to take into account network delays and server clock skews.\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * The credentials JSON file type for external account clients.\n * There are 3 types of JSON configs:\n * 1. authorized_user => Google end user credential\n * 2. service_account => Google service account credential\n * 3. external_Account => non-GCP service (eg. AWS, Azure, K8s)\n */\n\nexports.EXTERNAL_ACCOUNT_TYPE = 'external_account';\n/** Cloud resource manager URL used to retrieve project information. */\n\nexports.CLOUD_RESOURCE_MANAGER = 'https://cloudresourcemanager.googleapis.com/v1/projects/';\n/** The workforce audience pattern. */\n\nconst WORKFORCE_AUDIENCE_PATTERN = '//iam.googleapis.com/locations/[^/]+/workforcePools/[^/]+/providers/.+';\n/**\n * Base external account client. This is used to instantiate AuthClients for\n * exchanging external account credentials for GCP access token and authorizing\n * requests to GCP APIs.\n * The base class implements common logic for exchanging various type of\n * external credentials for GCP access token. The logic of determining and\n * retrieving the external credential based on the environment and\n * credential_source will be left for the subclasses.\n */\n\nclass BaseExternalAccountClient extends authclient_1.AuthClient {\n  /**\n   * Instantiate a BaseExternalAccountClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    super();\n\n    if (options.type !== exports.EXTERNAL_ACCOUNT_TYPE) {\n      throw new Error(\"Expected \\\"\".concat(exports.EXTERNAL_ACCOUNT_TYPE, \"\\\" type but \") + \"received \\\"\".concat(options.type, \"\\\"\"));\n    }\n\n    this.clientAuth = options.client_id ? {\n      confidentialClientType: 'basic',\n      clientId: options.client_id,\n      clientSecret: options.client_secret\n    } : undefined;\n\n    if (!this.validateGoogleAPIsUrl('sts', options.token_url)) {\n      throw new Error(\"\\\"\".concat(options.token_url, \"\\\" is not a valid token url.\"));\n    }\n\n    this.stsCredential = new sts.StsCredentials(options.token_url, this.clientAuth); // Default OAuth scope. This could be overridden via public property.\n\n    this.scopes = [DEFAULT_OAUTH_SCOPE];\n    this.cachedAccessToken = null;\n    this.audience = options.audience;\n    this.subjectTokenType = options.subject_token_type;\n    this.quotaProjectId = options.quota_project_id;\n    this.workforcePoolUserProject = options.workforce_pool_user_project;\n    const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);\n\n    if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {\n      throw new Error('workforcePoolUserProject should not be set for non-workforce pool ' + 'credentials.');\n    }\n\n    if (typeof options.service_account_impersonation_url !== 'undefined' && !this.validateGoogleAPIsUrl('iamcredentials', options.service_account_impersonation_url)) {\n      throw new Error(\"\\\"\".concat(options.service_account_impersonation_url, \"\\\" is \") + 'not a valid service account impersonation url.');\n    }\n\n    this.serviceAccountImpersonationUrl = options.service_account_impersonation_url; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    this.projectId = null;\n    this.projectNumber = this.getProjectNumber(this.audience);\n  }\n  /** The service account email to be impersonated, if available. */\n\n\n  getServiceAccountEmail() {\n    var _a;\n\n    if (this.serviceAccountImpersonationUrl) {\n      // Parse email from URL. The formal looks as follows:\n      // https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n      const re = _wrapRegExp(/serviceAccounts\\/([\\0-9;-\\uFFFF]+):generateAccessToken$/, {\n        email: 1\n      });\n\n      const result = re.exec(this.serviceAccountImpersonationUrl);\n      return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;\n    }\n\n    return null;\n  }\n  /**\n   * Provides a mechanism to inject GCP access tokens directly.\n   * When the provided credential expires, a new credential, using the\n   * external account options, is retrieved.\n   * @param credentials The Credentials object to set on the current client.\n   */\n\n\n  setCredentials(credentials) {\n    super.setCredentials(credentials);\n    this.cachedAccessToken = credentials;\n  }\n  /**\n   * @return A promise that resolves with the current GCP access token\n   *   response. If the current credential is expired, a new one is retrieved.\n   */\n\n\n  async getAccessToken() {\n    // If cached access token is unavailable or expired, force refresh.\n    if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {\n      await this.refreshAccessTokenAsync();\n    } // Return GCP access token in GetAccessTokenResponse format.\n\n\n    return {\n      token: this.cachedAccessToken.access_token,\n      res: this.cachedAccessToken.res\n    };\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   */\n\n\n  async getRequestHeaders() {\n    const accessTokenResponse = await this.getAccessToken();\n    const headers = {\n      Authorization: \"Bearer \".concat(accessTokenResponse.token)\n    };\n    return this.addSharedMetadataHeaders(headers);\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * @return A promise that resolves with the project ID corresponding to the\n   *   current workload identity pool or current workforce pool if\n   *   determinable. For workforce pool credential, it returns the project ID\n   *   corresponding to the workforcePoolUserProject.\n   *   This is introduced to match the current pattern of using the Auth\n   *   library:\n   *   const projectId = await auth.getProjectId();\n   *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;\n   *   const res = await client.request({ url });\n   *   The resource may not have permission\n   *   (resourcemanager.projects.get) to call this API or the required\n   *   scopes may not be selected:\n   *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n   */\n\n\n  async getProjectId() {\n    const projectNumber = this.projectNumber || this.workforcePoolUserProject;\n\n    if (this.projectId) {\n      // Return previously determined project ID.\n      return this.projectId;\n    } else if (projectNumber) {\n      // Preferable not to use request() to avoid retrial policies.\n      const headers = await this.getRequestHeaders();\n      const response = await this.transporter.request({\n        headers,\n        url: \"\".concat(exports.CLOUD_RESOURCE_MANAGER).concat(projectNumber),\n        responseType: 'json'\n      });\n      this.projectId = response.data.projectId;\n      return this.projectId;\n    }\n\n    return null;\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param retry Whether the current attempt is a retry after a failed attempt.\n   * @return A promise that resolves with the successful response.\n   */\n\n\n  async requestAsync(opts, retry = false) {\n    let response;\n\n    try {\n      const requestHeaders = await this.getRequestHeaders();\n      opts.headers = opts.headers || {};\n\n      if (requestHeaders && requestHeaders['x-goog-user-project']) {\n        opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n      }\n\n      if (requestHeaders && requestHeaders.Authorization) {\n        opts.headers.Authorization = requestHeaders.Authorization;\n      }\n\n      response = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n\n      if (res) {\n        const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - forceRefreshOnFailure is true\n\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n\n        if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n          await this.refreshAccessTokenAsync();\n          return await this.requestAsync(opts, true);\n        }\n      }\n\n      throw e;\n    }\n\n    return response;\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * External credentials are exchanged for GCP access tokens via the token\n   * exchange endpoint and other settings provided in the client options\n   * object.\n   * If the service_account_impersonation_url is provided, an additional\n   * step to exchange the external account GCP access token for a service\n   * account impersonated token is performed.\n   * @return A promise that resolves with the fresh GCP access tokens.\n   */\n\n\n  async refreshAccessTokenAsync() {\n    // Retrieve the external credential.\n    const subjectToken = await this.retrieveSubjectToken(); // Construct the STS credentials options.\n\n    const stsCredentialsOptions = {\n      grantType: STS_GRANT_TYPE,\n      audience: this.audience,\n      requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n      subjectToken,\n      subjectTokenType: this.subjectTokenType,\n      // generateAccessToken requires the provided access token to have\n      // scopes:\n      // https://www.googleapis.com/auth/iam or\n      // https://www.googleapis.com/auth/cloud-platform\n      // The new service account access token scopes will match the user\n      // provided ones.\n      scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()\n    }; // Exchange the external credentials for a GCP access token.\n    // Client auth is prioritized over passing the workforcePoolUserProject\n    // parameter for STS token exchange.\n\n    const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? {\n      userProject: this.workforcePoolUserProject\n    } : undefined;\n    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, additionalOptions);\n\n    if (this.serviceAccountImpersonationUrl) {\n      this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);\n    } else if (stsResponse.expires_in) {\n      // Save response in cached access token.\n      this.cachedAccessToken = {\n        access_token: stsResponse.access_token,\n        expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n        res: stsResponse.res\n      };\n    } else {\n      // Save response in cached access token.\n      this.cachedAccessToken = {\n        access_token: stsResponse.access_token,\n        res: stsResponse.res\n      };\n    } // Save credentials.\n\n\n    this.credentials = {};\n    Object.assign(this.credentials, this.cachedAccessToken);\n    delete this.credentials.res; // Trigger tokens event to notify external listeners.\n\n    this.emit('tokens', {\n      refresh_token: null,\n      expiry_date: this.cachedAccessToken.expiry_date,\n      access_token: this.cachedAccessToken.access_token,\n      token_type: 'Bearer',\n      id_token: null\n    }); // Return the cached access token.\n\n    return this.cachedAccessToken;\n  }\n  /**\n   * Returns the workload identity pool project number if it is determinable\n   * from the audience resource name.\n   * @param audience The STS audience used to determine the project number.\n   * @return The project number associated with the workload identity pool, if\n   *   this can be determined from the STS audience field. Otherwise, null is\n   *   returned.\n   */\n\n\n  getProjectNumber(audience) {\n    // STS audience pattern:\n    // //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n    const match = audience.match(/\\/projects\\/([^/]+)/);\n\n    if (!match) {\n      return null;\n    }\n\n    return match[1];\n  }\n  /**\n   * Exchanges an external account GCP access token for a service\n   * account impersonated access token using iamcredentials\n   * GenerateAccessToken API.\n   * @param token The access token to exchange for a service account access\n   *   token.\n   * @return A promise that resolves with the service account impersonated\n   *   credentials response.\n   */\n\n\n  async getImpersonatedAccessToken(token) {\n    const opts = {\n      url: this.serviceAccountImpersonationUrl,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: \"Bearer \".concat(token)\n      },\n      data: {\n        scope: this.getScopesArray()\n      },\n      responseType: 'json'\n    };\n    const response = await this.transporter.request(opts);\n    const successResponse = response.data;\n    return {\n      access_token: successResponse.accessToken,\n      // Convert from ISO format to timestamp.\n      expiry_date: new Date(successResponse.expireTime).getTime(),\n      res: response\n    };\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param accessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n\n\n  isExpired(accessToken) {\n    const now = new Date().getTime();\n    return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n  /**\n   * @return The list of scopes for the requested GCP access token.\n   */\n\n\n  getScopesArray() {\n    // Since scopes can be provided as string or array, the type should\n    // be normalized.\n    if (typeof this.scopes === 'string') {\n      return [this.scopes];\n    } else if (typeof this.scopes === 'undefined') {\n      return [DEFAULT_OAUTH_SCOPE];\n    } else {\n      return this.scopes;\n    }\n  }\n  /**\n   * Checks whether Google APIs URL is valid.\n   * @param apiName The apiName of url.\n   * @param url The Google API URL to validate.\n   * @return Whether the URL is valid or not.\n   */\n\n\n  validateGoogleAPIsUrl(apiName, url) {\n    let parsedUrl; // Return false if error is thrown during parsing URL.\n\n    try {\n      parsedUrl = new URL(url);\n    } catch (e) {\n      return false;\n    }\n\n    const urlDomain = parsedUrl.hostname; // Check the protocol is https.\n\n    if (parsedUrl.protocol !== 'https:') {\n      return false;\n    }\n\n    const googleAPIsDomainPatterns = [new RegExp('^' + VARIABLE_PORTION_PATTERN + '\\\\.' + apiName + GOOGLE_APIS_DOMAIN_PATTERN), new RegExp('^' + apiName + GOOGLE_APIS_DOMAIN_PATTERN), new RegExp('^' + apiName + '\\\\.' + VARIABLE_PORTION_PATTERN + GOOGLE_APIS_DOMAIN_PATTERN), new RegExp('^' + VARIABLE_PORTION_PATTERN + '\\\\-' + apiName + GOOGLE_APIS_DOMAIN_PATTERN)];\n\n    for (const googleAPIsDomainPattern of googleAPIsDomainPatterns) {\n      if (urlDomain.match(googleAPIsDomainPattern)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nexports.BaseExternalAccountClient = BaseExternalAccountClient;","map":null,"metadata":{},"sourceType":"script"}