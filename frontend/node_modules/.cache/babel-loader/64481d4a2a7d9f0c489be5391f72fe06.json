{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsClient = void 0;\n\nconst awsrequestsigner_1 = require(\"./awsrequestsigner\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\n * AWS external account client. This is used for AWS workloads, where\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\n * GCP access token.\n */\n\n\nclass AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n  /**\n   * Instantiates an AwsClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * An error is thrown if the credential is not a valid AWS credential.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    var _a;\n\n    super(options, additionalOptions);\n    this.environmentId = options.credential_source.environment_id; // This is only required if the AWS region is not available in the\n    // AWS_REGION or AWS_DEFAULT_REGION environment variables.\n\n    this.regionUrl = options.credential_source.region_url; // This is only required if AWS security credentials are not available in\n    // environment variables.\n\n    this.securityCredentialsUrl = options.credential_source.url;\n    this.regionalCredVerificationUrl = options.credential_source.regional_cred_verification_url;\n    const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n\n    if (!match || !this.regionalCredVerificationUrl) {\n      throw new Error('No valid AWS \"credential_source\" provided');\n    } else if (parseInt(match[2], 10) !== 1) {\n      throw new Error(\"aws version \\\"\".concat(match[2], \"\\\" is not supported in the current build.\"));\n    }\n\n    this.awsRequestSigner = null;\n    this.region = '';\n  }\n  /**\n   * Triggered when an external subject token is needed to be exchanged for a\n   * GCP access token via GCP STS endpoint.\n   * This uses the `options.credential_source` object to figure out how\n   * to retrieve the token using the current environment. In this case,\n   * this uses a serialized AWS signed request to the STS GetCallerIdentity\n   * endpoint.\n   * The logic is summarized as:\n   * 1. Retrieve AWS region from availability-zone.\n   * 2a. Check AWS credentials in environment variables. If not found, get\n   *     from security-credentials endpoint.\n   * 2b. Get AWS credentials from security-credentials endpoint. In order\n   *     to retrieve this, the AWS role needs to be determined by calling\n   *     security-credentials endpoint without any argument. Then the\n   *     credentials can be retrieved via: security-credentials/role_name\n   * 3. Generate the signed request to AWS STS GetCallerIdentity action.\n   * 4. Inject x-goog-cloud-target-resource into header and serialize the\n   *    signed request. This will be the subject-token to pass to GCP STS.\n   * @return A promise that resolves with the external subject token.\n   */\n\n\n  async retrieveSubjectToken() {\n    // Initialize AWS request signer if not already initialized.\n    if (!this.awsRequestSigner) {\n      this.region = await this.getAwsRegion();\n      this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {\n        // Check environment variables for permanent credentials first.\n        // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n        if (process.env['AWS_ACCESS_KEY_ID'] && process.env['AWS_SECRET_ACCESS_KEY']) {\n          return {\n            accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n            secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n            // This is normally not available for permanent credentials.\n            token: process.env['AWS_SESSION_TOKEN']\n          };\n        } // Since the role on a VM can change, we don't need to cache it.\n\n\n        const roleName = await this.getAwsRoleName(); // Temporary credentials typically last for several hours.\n        // Expiration is returned in response.\n        // Consider future optimization of this logic to cache AWS tokens\n        // until their natural expiration.\n\n        const awsCreds = await this.getAwsSecurityCredentials(roleName);\n        return {\n          accessKeyId: awsCreds.AccessKeyId,\n          secretAccessKey: awsCreds.SecretAccessKey,\n          token: awsCreds.Token\n        };\n      }, this.region);\n    } // Generate signed request to AWS STS GetCallerIdentity API.\n    // Use the required regional endpoint. Otherwise, the request will fail.\n\n\n    const options = await this.awsRequestSigner.getRequestOptions({\n      url: this.regionalCredVerificationUrl.replace('{region}', this.region),\n      method: 'POST'\n    }); // The GCP STS endpoint expects the headers to be formatted as:\n    // [\n    //   {key: 'x-amz-date', value: '...'},\n    //   {key: 'Authorization', value: '...'},\n    //   ...\n    // ]\n    // And then serialized as:\n    // encodeURIComponent(JSON.stringify({\n    //   url: '...',\n    //   method: 'POST',\n    //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n    // }))\n\n    const reformattedHeader = [];\n    const extendedHeaders = Object.assign({\n      // The full, canonical resource name of the workload identity pool\n      // provider, with or without the HTTPS prefix.\n      // Including this header as part of the signature is recommended to\n      // ensure data integrity.\n      'x-goog-cloud-target-resource': this.audience\n    }, options.headers); // Reformat header to GCP STS expected format.\n\n    for (const key in extendedHeaders) {\n      reformattedHeader.push({\n        key,\n        value: extendedHeaders[key]\n      });\n    } // Serialize the reformatted signed request.\n\n\n    return encodeURIComponent(JSON.stringify({\n      url: options.url,\n      method: options.method,\n      headers: reformattedHeader\n    }));\n  }\n  /**\n   * @return A promise that resolves with the current AWS region.\n   */\n\n\n  async getAwsRegion() {\n    // Priority order for region determination:\n    // AWS_REGION > AWS_DEFAULT_REGION > metadata server.\n    if (process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION']) {\n      return process.env['AWS_REGION'] || process.env['AWS_DEFAULT_REGION'];\n    }\n\n    if (!this.regionUrl) {\n      throw new Error('Unable to determine AWS region due to missing ' + '\"options.credential_source.region_url\"');\n    }\n\n    const opts = {\n      url: this.regionUrl,\n      method: 'GET',\n      responseType: 'text'\n    };\n    const response = await this.transporter.request(opts); // Remove last character. For example, if us-east-2b is returned,\n    // the region would be us-east-2.\n\n    return response.data.substr(0, response.data.length - 1);\n  }\n  /**\n   * @return A promise that resolves with the assigned role to the current\n   *   AWS VM. This is needed for calling the security-credentials endpoint.\n   */\n\n\n  async getAwsRoleName() {\n    if (!this.securityCredentialsUrl) {\n      throw new Error('Unable to determine AWS role name due to missing ' + '\"options.credential_source.url\"');\n    }\n\n    const opts = {\n      url: this.securityCredentialsUrl,\n      method: 'GET',\n      responseType: 'text'\n    };\n    const response = await this.transporter.request(opts);\n    return response.data;\n  }\n  /**\n   * Retrieves the temporary AWS credentials by calling the security-credentials\n   * endpoint as specified in the `credential_source` object.\n   * @param roleName The role attached to the current VM.\n   * @return A promise that resolves with the temporary AWS credentials\n   *   needed for creating the GetCallerIdentity signed request.\n   */\n\n\n  async getAwsSecurityCredentials(roleName) {\n    const response = await this.transporter.request({\n      url: \"\".concat(this.securityCredentialsUrl, \"/\").concat(roleName),\n      responseType: 'json'\n    });\n    return response.data;\n  }\n\n}\n\nexports.AwsClient = AwsClient;","map":null,"metadata":{},"sourceType":"script"}