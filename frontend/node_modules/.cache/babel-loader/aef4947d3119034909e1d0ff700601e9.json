{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsRequestSigner = void 0;\n\nconst crypto_1 = require(\"../crypto/crypto\");\n/** AWS Signature Version 4 signing algorithm identifier.  */\n\n\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\n/**\n * The termination string for the AWS credential scope value as defined in\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n */\n\nconst AWS_REQUEST_TYPE = 'aws4_request';\n/**\n * Implements an AWS API request signer based on the AWS Signature Version 4\n * signing process.\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n */\n\nclass AwsRequestSigner {\n  /**\n   * Instantiates an AWS API request signer used to send authenticated signed\n   * requests to AWS APIs based on the AWS Signature Version 4 signing process.\n   * This also provides a mechanism to generate the signed request without\n   * sending it.\n   * @param getCredentials A mechanism to retrieve AWS security credentials\n   *   when needed.\n   * @param region The AWS region to use.\n   */\n  constructor(getCredentials, region) {\n    this.getCredentials = getCredentials;\n    this.region = region;\n    this.crypto = crypto_1.createCrypto();\n  }\n  /**\n   * Generates the signed request for the provided HTTP request for calling\n   * an AWS API. This follows the steps described at:\n   * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n   * @param amzOptions The AWS request options that need to be signed.\n   * @return A promise that resolves with the GaxiosOptions containing the\n   *   signed HTTP request parameters.\n   */\n\n\n  async getRequestOptions(amzOptions) {\n    if (!amzOptions.url) {\n      throw new Error('\"url\" is required in \"amzOptions\"');\n    } // Stringify JSON requests. This will be set in the request body of the\n    // generated signed request.\n\n\n    const requestPayloadData = typeof amzOptions.data === 'object' ? JSON.stringify(amzOptions.data) : amzOptions.data;\n    const url = amzOptions.url;\n    const method = amzOptions.method || 'GET';\n    const requestPayload = amzOptions.body || requestPayloadData;\n    const additionalAmzHeaders = amzOptions.headers;\n    const awsSecurityCredentials = await this.getCredentials();\n    const uri = new URL(url);\n    const headerMap = await generateAuthenticationHeaderMap({\n      crypto: this.crypto,\n      host: uri.host,\n      canonicalUri: uri.pathname,\n      canonicalQuerystring: uri.search.substr(1),\n      method,\n      region: this.region,\n      securityCredentials: awsSecurityCredentials,\n      requestPayload,\n      additionalAmzHeaders\n    }); // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n\n    const headers = Object.assign( // Add x-amz-date if available.\n    headerMap.amzDate ? {\n      'x-amz-date': headerMap.amzDate\n    } : {}, {\n      Authorization: headerMap.authorizationHeader,\n      host: uri.host\n    }, additionalAmzHeaders || {});\n\n    if (awsSecurityCredentials.token) {\n      Object.assign(headers, {\n        'x-amz-security-token': awsSecurityCredentials.token\n      });\n    }\n\n    const awsSignedReq = {\n      url,\n      method: method,\n      headers\n    };\n\n    if (typeof requestPayload !== 'undefined') {\n      awsSignedReq.body = requestPayload;\n    }\n\n    return awsSignedReq;\n  }\n\n}\n\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\n * Creates the HMAC-SHA256 hash of the provided message using the\n * provided key.\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The HMAC-SHA256 key to use.\n * @param msg The message to hash.\n * @return The computed hash bytes.\n */\n\nasync function sign(crypto, key, msg) {\n  return await crypto.signWithHmacSha256(key, msg);\n}\n/**\n * Calculates the signing key used to calculate the signature for\n * AWS Signature Version 4 based on:\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n *\n * @param crypto The crypto instance used to facilitate cryptographic\n *   operations.\n * @param key The AWS secret access key.\n * @param dateStamp The '%Y%m%d' date format.\n * @param region The AWS region.\n * @param serviceName The AWS service name, eg. sts.\n * @return The signing key bytes.\n */\n\n\nasync function getSigningKey(crypto, key, dateStamp, region, serviceName) {\n  const kDate = await sign(crypto, \"AWS4\".concat(key), dateStamp);\n  const kRegion = await sign(crypto, kDate, region);\n  const kService = await sign(crypto, kRegion, serviceName);\n  const kSigning = await sign(crypto, kService, 'aws4_request');\n  return kSigning;\n}\n/**\n * Generates the authentication header map needed for generating the AWS\n * Signature Version 4 signed request.\n *\n * @param option The options needed to compute the authentication header map.\n * @return The AWS authentication header map which constitutes of the following\n *   components: amz-date, authorization header and canonical query string.\n */\n\n\nasync function generateAuthenticationHeaderMap(options) {\n  const additionalAmzHeaders = options.additionalAmzHeaders || {};\n  const requestPayload = options.requestPayload || ''; // iam.amazonaws.com host => iam service.\n  // sts.us-east-2.amazonaws.com => sts service.\n\n  const serviceName = options.host.split('.')[0];\n  const now = new Date(); // Format: '%Y%m%dT%H%M%SZ'.\n\n  const amzDate = now.toISOString().replace(/[-:]/g, '').replace(/\\.[0-9]+/, ''); // Format: '%Y%m%d'.\n\n  const dateStamp = now.toISOString().replace(/[-]/g, '').replace(/T.*/, ''); // Change all additional headers to be lower case.\n\n  const reformattedAdditionalAmzHeaders = {};\n  Object.keys(additionalAmzHeaders).forEach(key => {\n    reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];\n  }); // Add AWS token if available.\n\n  if (options.securityCredentials.token) {\n    reformattedAdditionalAmzHeaders['x-amz-security-token'] = options.securityCredentials.token;\n  } // Header keys need to be sorted alphabetically.\n\n\n  const amzHeaders = Object.assign({\n    host: options.host\n  }, // Previously the date was not fixed with x-amz- and could be provided manually.\n  // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n  reformattedAdditionalAmzHeaders.date ? {} : {\n    'x-amz-date': amzDate\n  }, reformattedAdditionalAmzHeaders);\n  let canonicalHeaders = '';\n  const signedHeadersList = Object.keys(amzHeaders).sort();\n  signedHeadersList.forEach(key => {\n    canonicalHeaders += \"\".concat(key, \":\").concat(amzHeaders[key], \"\\n\");\n  });\n  const signedHeaders = signedHeadersList.join(';');\n  const payloadHash = await options.crypto.sha256DigestHex(requestPayload); // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n\n  const canonicalRequest = \"\".concat(options.method, \"\\n\") + \"\".concat(options.canonicalUri, \"\\n\") + \"\".concat(options.canonicalQuerystring, \"\\n\") + \"\".concat(canonicalHeaders, \"\\n\") + \"\".concat(signedHeaders, \"\\n\") + \"\".concat(payloadHash);\n  const credentialScope = \"\".concat(dateStamp, \"/\").concat(options.region, \"/\").concat(serviceName, \"/\").concat(AWS_REQUEST_TYPE); // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n\n  const stringToSign = \"\".concat(AWS_ALGORITHM, \"\\n\") + \"\".concat(amzDate, \"\\n\") + \"\".concat(credentialScope, \"\\n\") + (await options.crypto.sha256DigestHex(canonicalRequest)); // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n\n  const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n  const signature = await sign(options.crypto, signingKey, stringToSign); // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n\n  const authorizationHeader = \"\".concat(AWS_ALGORITHM, \" Credential=\").concat(options.securityCredentials.accessKeyId, \"/\") + \"\".concat(credentialScope, \", SignedHeaders=\").concat(signedHeaders, \", \") + \"Signature=\".concat(crypto_1.fromArrayBufferToHex(signature));\n  return {\n    // Do not return x-amz-date if date is available.\n    amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n    authorizationHeader,\n    canonicalQuerystring: options.canonicalQuerystring\n  };\n}","map":null,"metadata":{},"sourceType":"script"}