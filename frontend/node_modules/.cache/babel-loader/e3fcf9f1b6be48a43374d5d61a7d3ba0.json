{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _slicedToArray = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toProto3JSON = void 0;\n\nconst assert = require(\"assert\");\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst util_1 = require(\"./util\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nconst id = x => {\n  return x;\n};\n\nfunction toProto3JSON(obj) {\n  const objType = obj.$type;\n\n  if (!objType) {\n    throw new Error('Cannot serialize object to proto3 JSON since its .$type is unknown. Use Type.fromObject(obj) before calling toProto3JSON.');\n  }\n\n  objType.resolveAll();\n  const typeName = (0, util_1.getFullyQualifiedTypeName)(objType); // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n\n  if (typeName === '.google.protobuf.Any') {\n    return (0, any_1.googleProtobufAnyToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Value') {\n    return (0, value_1.googleProtobufValueToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Struct') {\n    return (0, value_1.googleProtobufStructToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.ListValue') {\n    return (0, value_1.googleProtobufListValueToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Duration') {\n    return (0, duration_1.googleProtobufDurationToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.Timestamp') {\n    return (0, timestamp_1.googleProtobufTimestampToProto3JSON)(obj);\n  }\n\n  if (typeName === '.google.protobuf.FieldMask') {\n    return (0, fieldmask_1.googleProtobufFieldMaskToProto3JSON)(obj);\n  }\n\n  if (util_1.wrapperTypes.has(typeName)) {\n    return (0, wrappers_1.wrapperToProto3JSON)(obj);\n  }\n\n  const result = {};\n\n  for (const _ref of Object.entries(obj)) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    const key = _ref2[0];\n    const value = _ref2[1];\n    const field = objType.fields[key];\n    const fieldResolvedType = field.resolvedType;\n    const fieldFullyQualifiedTypeName = fieldResolvedType ? (0, util_1.getFullyQualifiedTypeName)(fieldResolvedType) : null;\n\n    if (value === null) {\n      result[key] = null;\n      continue;\n    }\n\n    if (Array.isArray(value)) {\n      if (value.length === 0) {\n        // ignore repeated fields with no values\n        continue;\n      } // if the repeated value has a complex type, convert it to proto3 JSON, otherwise use as is\n\n\n      result[key] = value.map(fieldResolvedType ? element => {\n        return toProto3JSON(element);\n      } : id);\n      continue;\n    }\n\n    if (field.map) {\n      const map = {};\n\n      for (const _ref3 of Object.entries(value)) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const mapKey = _ref4[0];\n        const mapValue = _ref4[1];\n        // if the map value has a complex type, convert it to proto3 JSON, otherwise use as is\n        map[mapKey] = fieldResolvedType ? toProto3JSON(mapValue) : mapValue;\n      }\n\n      result[key] = map;\n      continue;\n    }\n\n    if (fieldFullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      result[key] = null;\n      continue;\n    }\n\n    if (fieldResolvedType && 'values' in fieldResolvedType && value !== null) {\n      result[key] = (0, enum_1.resolveEnumValueToString)(fieldResolvedType, value);\n      continue;\n    }\n\n    if (fieldResolvedType) {\n      result[key] = toProto3JSON(value);\n      continue;\n    }\n\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n      if (typeof value === 'number' && !Number.isFinite(value)) {\n        result[key] = value.toString();\n        continue;\n      }\n\n      result[key] = value;\n      continue;\n    }\n\n    if (Buffer.isBuffer(value) || value instanceof Uint8Array) {\n      result[key] = (0, bytes_1.bytesToProto3JSON)(value);\n      continue;\n    } // The remaining case is Long, everything else is an internal error\n\n\n    assert(value.constructor.name === 'Long', \"toProto3JSON: don't know how to convert field \".concat(key, \" with value \").concat(value));\n    result[key] = value.toString();\n    continue;\n  }\n\n  return result;\n}\n\nexports.toProto3JSON = toProto3JSON;","map":null,"metadata":{},"sourceType":"script"}