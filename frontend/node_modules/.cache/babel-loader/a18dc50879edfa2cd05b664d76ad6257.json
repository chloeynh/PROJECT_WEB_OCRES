{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _a, _b, _c;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IdentityPoolClient = void 0;\n\nconst fs = require(\"fs\");\n\nconst util_1 = require(\"util\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\"); // fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\n\n\nconst readFile = util_1.promisify((_a = fs.readFile) !== null && _a !== void 0 ? _a : () => {});\nconst realpath = util_1.promisify((_b = fs.realpath) !== null && _b !== void 0 ? _b : () => {});\nconst lstat = util_1.promisify((_c = fs.lstat) !== null && _c !== void 0 ? _c : () => {});\n/**\n * Defines the Url-sourced and file-sourced external account clients mainly\n * used for K8s and Azure workloads.\n */\n\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n  /**\n   * Instantiate an IdentityPoolClient instance using the provided JSON\n   * object loaded from an external account credentials file.\n   * An error is thrown if the credential is not a valid file-sourced or\n   * url-sourced credential or a workforce pool user project is provided\n   * with a non workforce audience.\n   * @param options The external account options object typically loaded\n   *   from the external account JSON credential file.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   */\n  constructor(options, additionalOptions) {\n    var _a, _b;\n\n    super(options, additionalOptions);\n    this.file = options.credential_source.file;\n    this.url = options.credential_source.url;\n    this.headers = options.credential_source.headers;\n\n    if (!this.file && !this.url) {\n      throw new Error('No valid Identity Pool \"credential_source\" provided');\n    } // Text is the default format type.\n\n\n    this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';\n    this.formatSubjectTokenFieldName = (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\n\n    if (this.formatType !== 'json' && this.formatType !== 'text') {\n      throw new Error(\"Invalid credential_source format \\\"\".concat(this.formatType, \"\\\"\"));\n    }\n\n    if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n      throw new Error('Missing subject_token_field_name for JSON credential_source format');\n    }\n  }\n  /**\n   * Triggered when a external subject token is needed to be exchanged for a GCP\n   * access token via GCP STS endpoint.\n   * This uses the `options.credential_source` object to figure out how\n   * to retrieve the token using the current environment. In this case,\n   * this either retrieves the local credential from a file location (k8s\n   * workload) or by sending a GET request to a local metadata server (Azure\n   * workloads).\n   * @return A promise that resolves with the external subject token.\n   */\n\n\n  async retrieveSubjectToken() {\n    if (this.file) {\n      return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n    }\n\n    return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n  }\n  /**\n   * Looks up the external subject token in the file path provided and\n   * resolves with that token.\n   * @param file The file path where the external credential is located.\n   * @param formatType The token file or URL response type (JSON or text).\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\n   *   subject_token field name. For Azure, this is access_token. For text\n   *   response types, this is ignored.\n   * @return A promise that resolves with the external subject token.\n   */\n\n\n  async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = await realpath(filePath);\n\n      if (!(await lstat(filePath)).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      err.message = \"The file at \".concat(filePath, \" does not exist, or it is not a file. \").concat(err.message);\n      throw err;\n    }\n\n    let subjectToken;\n    const rawText = await readFile(filePath, {\n      encoding: 'utf8'\n    });\n\n    if (formatType === 'text') {\n      subjectToken = rawText;\n    } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n      const json = JSON.parse(rawText);\n      subjectToken = json[formatSubjectTokenFieldName];\n    }\n\n    if (!subjectToken) {\n      throw new Error('Unable to parse the subject_token from the credential_source file');\n    }\n\n    return subjectToken;\n  }\n  /**\n   * Sends a GET request to the URL provided and resolves with the returned\n   * external subject token.\n   * @param url The URL to call to retrieve the subject token. This is typically\n   *   a local metadata server.\n   * @param formatType The token file or URL response type (JSON or text).\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\n   *   subject_token field name. For Azure, this is access_token. For text\n   *   response types, this is ignored.\n   * @param headers The optional additional headers to send with the request to\n   *   the metadata server url.\n   * @return A promise that resolves with the external subject token.\n   */\n\n\n  async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n    const opts = {\n      url,\n      method: 'GET',\n      headers,\n      responseType: formatType\n    };\n    let subjectToken;\n\n    if (formatType === 'text') {\n      const response = await this.transporter.request(opts);\n      subjectToken = response.data;\n    } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n      const response = await this.transporter.request(opts);\n      subjectToken = response.data[formatSubjectTokenFieldName];\n    }\n\n    if (!subjectToken) {\n      throw new Error('Unable to parse the subject_token from the credential_source URL');\n    }\n\n    return subjectToken;\n  }\n\n}\n\nexports.IdentityPoolClient = IdentityPoolClient;","map":null,"metadata":{},"sourceType":"script"}