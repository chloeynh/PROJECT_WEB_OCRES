{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleToken = void 0;\n\nconst fs = require(\"fs\");\n\nconst gaxios_1 = require(\"gaxios\");\n\nconst jws = require(\"jws\");\n\nconst path = require(\"path\");\n\nconst util_1 = require(\"util\");\n\nconst readFile = fs.readFile ? util_1.promisify(fs.readFile) : async () => {\n  // if running in the web-browser, fs.readFile may not have been shimmed.\n  throw new ErrorWithCode('use key rather than keyFile.', 'MISSING_CREDENTIALS');\n};\nconst GOOGLE_TOKEN_URL = 'https://www.googleapis.com/oauth2/v4/token';\nconst GOOGLE_REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke?token=';\n\nclass ErrorWithCode extends Error {\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n\n}\n\nlet getPem;\n\nclass GoogleToken {\n  /**\n   * Create a GoogleToken.\n   *\n   * @param options  Configuration object.\n   */\n  constructor(options) {\n    this.configure(options);\n  }\n\n  get accessToken() {\n    return this.rawToken ? this.rawToken.access_token : undefined;\n  }\n\n  get idToken() {\n    return this.rawToken ? this.rawToken.id_token : undefined;\n  }\n\n  get tokenType() {\n    return this.rawToken ? this.rawToken.token_type : undefined;\n  }\n\n  get refreshToken() {\n    return this.rawToken ? this.rawToken.refresh_token : undefined;\n  }\n  /**\n   * Returns whether the token has expired.\n   *\n   * @return true if the token has expired, false otherwise.\n   */\n\n\n  hasExpired() {\n    const now = new Date().getTime();\n\n    if (this.rawToken && this.expiresAt) {\n      return now >= this.expiresAt;\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Returns whether the token will expire within eagerRefreshThresholdMillis\n   *\n   * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.\n   */\n\n\n  isTokenExpiring() {\n    var _a;\n\n    const now = new Date().getTime();\n    const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;\n\n    if (this.rawToken && this.expiresAt) {\n      return this.expiresAt <= now + eagerRefreshThresholdMillis;\n    } else {\n      return true;\n    }\n  }\n\n  getToken(callback, opts = {}) {\n    if (typeof callback === 'object') {\n      opts = callback;\n      callback = undefined;\n    }\n\n    opts = Object.assign({\n      forceRefresh: false\n    }, opts);\n\n    if (callback) {\n      const cb = callback;\n      this.getTokenAsync(opts).then(t => cb(null, t), callback);\n      return;\n    }\n\n    return this.getTokenAsync(opts);\n  }\n  /**\n   * Given a keyFile, extract the key and client email if available\n   * @param keyFile Path to a json, pem, or p12 file that contains the key.\n   * @returns an object with privateKey and clientEmail properties\n   */\n\n\n  async getCredentials(keyFile) {\n    const ext = path.extname(keyFile);\n\n    switch (ext) {\n      case '.json':\n        {\n          const key = await readFile(keyFile, 'utf8');\n          const body = JSON.parse(key);\n          const privateKey = body.private_key;\n          const clientEmail = body.client_email;\n\n          if (!privateKey || !clientEmail) {\n            throw new ErrorWithCode('private_key and client_email are required.', 'MISSING_CREDENTIALS');\n          }\n\n          return {\n            privateKey,\n            clientEmail\n          };\n        }\n\n      case '.der':\n      case '.crt':\n      case '.pem':\n        {\n          const privateKey = await readFile(keyFile, 'utf8');\n          return {\n            privateKey\n          };\n        }\n\n      case '.p12':\n      case '.pfx':\n        {\n          // NOTE:  The loading of `google-p12-pem` is deferred for performance\n          // reasons.  The `node-forge` npm module in `google-p12-pem` adds a fair\n          // bit time to overall module loading, and is likely not frequently\n          // used.  In a future release, p12 support will be entirely removed.\n          if (!getPem) {\n            getPem = (await Promise.resolve().then(() => require('google-p12-pem'))).getPem;\n          }\n\n          const privateKey = await getPem(keyFile);\n          return {\n            privateKey\n          };\n        }\n\n      default:\n        throw new ErrorWithCode('Unknown certificate type. Type is determined based on file extension. ' + 'Current supported extensions are *.json, *.pem, and *.p12.', 'UNKNOWN_CERTIFICATE_TYPE');\n    }\n  }\n\n  async getTokenAsync(opts) {\n    if (this.inFlightRequest && !opts.forceRefresh) {\n      return this.inFlightRequest;\n    }\n\n    try {\n      return await (this.inFlightRequest = this.getTokenAsyncInner(opts));\n    } finally {\n      this.inFlightRequest = undefined;\n    }\n  }\n\n  async getTokenAsyncInner(opts) {\n    if (this.isTokenExpiring() === false && opts.forceRefresh === false) {\n      return Promise.resolve(this.rawToken);\n    }\n\n    if (!this.key && !this.keyFile) {\n      throw new Error('No key or keyFile set.');\n    }\n\n    if (!this.key && this.keyFile) {\n      const creds = await this.getCredentials(this.keyFile);\n      this.key = creds.privateKey;\n      this.iss = creds.clientEmail || this.iss;\n\n      if (!creds.clientEmail) {\n        this.ensureEmail();\n      }\n    }\n\n    return this.requestToken();\n  }\n\n  ensureEmail() {\n    if (!this.iss) {\n      throw new ErrorWithCode('email is required.', 'MISSING_CREDENTIALS');\n    }\n  }\n\n  revokeToken(callback) {\n    if (callback) {\n      this.revokeTokenAsync().then(() => callback(), callback);\n      return;\n    }\n\n    return this.revokeTokenAsync();\n  }\n\n  async revokeTokenAsync() {\n    if (!this.accessToken) {\n      throw new Error('No token to revoke.');\n    }\n\n    const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;\n    await gaxios_1.request({\n      url\n    });\n    this.configure({\n      email: this.iss,\n      sub: this.sub,\n      key: this.key,\n      keyFile: this.keyFile,\n      scope: this.scope,\n      additionalClaims: this.additionalClaims\n    });\n  }\n  /**\n   * Configure the GoogleToken for re-use.\n   * @param  {object} options Configuration object.\n   */\n\n\n  configure(options = {}) {\n    this.keyFile = options.keyFile;\n    this.key = options.key;\n    this.rawToken = undefined;\n    this.iss = options.email || options.iss;\n    this.sub = options.sub;\n    this.additionalClaims = options.additionalClaims;\n\n    if (typeof options.scope === 'object') {\n      this.scope = options.scope.join(' ');\n    } else {\n      this.scope = options.scope;\n    }\n\n    this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;\n  }\n  /**\n   * Request the token from Google.\n   */\n\n\n  async requestToken() {\n    const iat = Math.floor(new Date().getTime() / 1000);\n    const additionalClaims = this.additionalClaims || {};\n    const payload = Object.assign({\n      iss: this.iss,\n      scope: this.scope,\n      aud: GOOGLE_TOKEN_URL,\n      exp: iat + 3600,\n      iat,\n      sub: this.sub\n    }, additionalClaims);\n    const signedJWT = jws.sign({\n      header: {\n        alg: 'RS256'\n      },\n      payload,\n      secret: this.key\n    });\n\n    try {\n      const r = await gaxios_1.request({\n        method: 'POST',\n        url: GOOGLE_TOKEN_URL,\n        data: {\n          grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',\n          assertion: signedJWT\n        },\n        headers: {\n          'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        responseType: 'json'\n      });\n      this.rawToken = r.data;\n      this.expiresAt = r.data.expires_in === null || r.data.expires_in === undefined ? undefined : (iat + r.data.expires_in) * 1000;\n      return this.rawToken;\n    } catch (e) {\n      this.rawToken = undefined;\n      this.tokenExpires = undefined;\n      const body = e.response && e.response.data ? e.response.data : {};\n\n      if (body.error) {\n        const desc = body.error_description ? \": \".concat(body.error_description) : '';\n        e.message = \"\".concat(body.error).concat(desc);\n      }\n\n      throw e;\n    }\n  }\n\n}\n\nexports.GoogleToken = GoogleToken;","map":null,"metadata":{},"sourceType":"script"}