{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _slicedToArray = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromProto3JSON = exports.fromProto3JSONToInternalRepresentation = void 0;\n\nconst assert = require(\"assert\");\n\nconst any_1 = require(\"./any\");\n\nconst bytes_1 = require(\"./bytes\");\n\nconst enum_1 = require(\"./enum\");\n\nconst value_1 = require(\"./value\");\n\nconst util_1 = require(\"./util\");\n\nconst duration_1 = require(\"./duration\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst wrappers_1 = require(\"./wrappers\");\n\nconst fieldmask_1 = require(\"./fieldmask\");\n\nfunction fromProto3JSONToInternalRepresentation(type, json) {\n  const fullyQualifiedTypeName = typeof type === 'string' ? type : (0, util_1.getFullyQualifiedTypeName)(type);\n\n  if (typeof type !== 'string' && 'values' in type) {\n    // type is an Enum\n    if (fullyQualifiedTypeName === '.google.protobuf.NullValue') {\n      return 'NULL_VALUE';\n    }\n\n    return (0, enum_1.resolveEnumValueToString)(type, json);\n  }\n\n  if (typeof type !== 'string') {\n    type.resolveAll();\n  }\n\n  if (typeof type === 'string') {\n    return json;\n  } // Types that require special handling according to\n  // https://developers.google.com/protocol-buffers/docs/proto3#json\n  // Types that can have meaningful \"null\" value\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Value') {\n    return (0, value_1.googleProtobufValueFromProto3JSON)(json);\n  }\n\n  if (util_1.wrapperTypes.has(fullyQualifiedTypeName)) {\n    if (json !== null && typeof json === 'object' || Array.isArray(json)) {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: JSON representation for \".concat(fullyQualifiedTypeName, \" expects a string, a number, or a boolean, but got \").concat(typeof json));\n    }\n\n    return (0, wrappers_1.wrapperFromProto3JSON)(fullyQualifiedTypeName, json);\n  }\n\n  if (json === null) {\n    return null;\n  } // Types that cannot be \"null\"\n\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Any') {\n    return (0, any_1.googleProtobufAnyFromProto3JSON)(type.root, json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Struct') {\n    if (typeof json !== 'object') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got \".concat(typeof json));\n    }\n\n    if (Array.isArray(json)) {\n      throw new Error('fromProto3JSONToInternalRepresentation: google.protobuf.Struct must be an object but got an array');\n    }\n\n    return (0, value_1.googleProtobufStructFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.ListValue') {\n    if (!Array.isArray(json)) {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.ListValue must be an array but got \".concat(typeof json));\n    }\n\n    return (0, value_1.googleProtobufListValueFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Duration') {\n    if (typeof json !== 'string') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.Duration must be a string but got \".concat(typeof json));\n    }\n\n    return (0, duration_1.googleProtobufDurationFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.Timestamp') {\n    if (typeof json !== 'string') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.Timestamp must be a string but got \".concat(typeof json));\n    }\n\n    return (0, timestamp_1.googleProtobufTimestampFromProto3JSON)(json);\n  }\n\n  if (fullyQualifiedTypeName === '.google.protobuf.FieldMask') {\n    if (typeof json !== 'string') {\n      throw new Error(\"fromProto3JSONToInternalRepresentation: google.protobuf.FieldMask must be a string but got \".concat(typeof json));\n    }\n\n    return (0, fieldmask_1.googleProtobufFieldMaskFromProto3JSON)(json);\n  }\n\n  const result = {};\n\n  for (const _ref of Object.entries(json)) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    const key = _ref2[0];\n    const value = _ref2[1];\n    const field = type.fields[key];\n\n    if (!field) {\n      continue;\n    }\n\n    const resolvedType = field.resolvedType;\n    const fieldType = field.type;\n\n    if (field.repeated) {\n      if (!Array.isArray(value)) {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: expected an array for field \".concat(key));\n      }\n\n      result[key] = value.map(element => fromProto3JSONToInternalRepresentation(resolvedType || fieldType, element));\n    } else if (field.map) {\n      const map = {};\n\n      for (const _ref3 of Object.entries(value)) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const mapKey = _ref4[0];\n        const mapValue = _ref4[1];\n        map[mapKey] = fromProto3JSONToInternalRepresentation(resolvedType || fieldType, mapValue);\n      }\n\n      result[key] = map;\n    } else if (fieldType.match(/^(?:(?:(?:u?int|fixed)(?:32|64))|float|double)$/)) {\n      if (typeof value !== 'number' && typeof value !== 'string') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'string') {\n      if (typeof value !== 'string') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bool') {\n      if (typeof value !== 'boolean') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = value;\n    } else if (fieldType === 'bytes') {\n      if (typeof value !== 'string') {\n        throw new Error(\"fromProto3JSONToInternalRepresentation: field \".concat(key, \" of type \").concat(field.type, \" cannot contain value \").concat(value));\n      }\n\n      result[key] = (0, bytes_1.bytesFromProto3JSON)(value);\n    } else {\n      // Message type\n      assert(resolvedType, \"Expected to be able to resolve type for field \".concat(field.name));\n      const deserializedValue = fromProto3JSONToInternalRepresentation(resolvedType, value);\n      result[key] = deserializedValue;\n    }\n  }\n\n  return result;\n}\n\nexports.fromProto3JSONToInternalRepresentation = fromProto3JSONToInternalRepresentation;\n\nfunction fromProto3JSON(type, json) {\n  const internalRepr = fromProto3JSONToInternalRepresentation(type, json);\n\n  if (internalRepr === null) {\n    return null;\n  } // We only expect a real object here sine all special cases should be already resolved. Everything else is an internal error\n\n\n  assert(typeof internalRepr === 'object' && !Array.isArray(internalRepr), \"fromProto3JSON: expected an object, not \".concat(json));\n  return type.fromObject(internalRepr);\n}\n\nexports.fromProto3JSON = fromProto3JSON;","map":null,"metadata":{},"sourceType":"script"}