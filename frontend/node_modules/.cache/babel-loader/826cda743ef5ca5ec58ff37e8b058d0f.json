{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;\n\nconst stream = require(\"stream\");\n\nconst authclient_1 = require(\"./authclient\");\n\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\n\n\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\n\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\n\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\n\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1/token';\n/**\n * The maximum number of access boundary rules a Credential Access Boundary\n * can contain.\n */\n\nexports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;\n/**\n * Offset to take into account network delays and server clock skews.\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n/**\n * Defines a set of Google credentials that are downscoped from an existing set\n * of Google OAuth2 credentials. This is useful to restrict the Identity and\n * Access Management (IAM) permissions that a short-lived credential can use.\n * The common pattern of usage is to have a token broker with elevated access\n * generate these downscoped credentials from higher access source credentials\n * and pass the downscoped short-lived access tokens to a token consumer via\n * some secure authenticated channel for limited access to Google Cloud Storage\n * resources.\n */\n\nclass DownscopedClient extends authclient_1.AuthClient {\n  /**\n   * Instantiates a downscoped client object using the provided source\n   * AuthClient and credential access boundary rules.\n   * To downscope permissions of a source AuthClient, a Credential Access\n   * Boundary that specifies which resources the new credential can access, as\n   * well as an upper bound on the permissions that are available on each\n   * resource, has to be defined. A downscoped client can then be instantiated\n   * using the source AuthClient and the Credential Access Boundary.\n   * @param authClient The source AuthClient to be downscoped based on the\n   *   provided Credential Access Boundary rules.\n   * @param credentialAccessBoundary The Credential Access Boundary which\n   *   contains a list of access boundary rules. Each rule contains information\n   *   on the resource that the rule applies to, the upper bound of the\n   *   permissions that are available on that resource and an optional\n   *   condition to further restrict permissions.\n   * @param additionalOptions Optional additional behavior customization\n   *   options. These currently customize expiration threshold time and\n   *   whether to retry on 401/403 API request errors.\n   * @param quotaProjectId Optional quota project id for setting up in the\n   *   x-goog-user-project header.\n   */\n  constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {\n    super();\n    this.authClient = authClient;\n    this.credentialAccessBoundary = credentialAccessBoundary; // Check 1-10 Access Boundary Rules are defined within Credential Access\n    // Boundary.\n\n    if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {\n      throw new Error('At least one access boundary rule needs to be defined.');\n    } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {\n      throw new Error('The provided access boundary has more than ' + \"\".concat(exports.MAX_ACCESS_BOUNDARY_RULES_COUNT, \" access boundary rules.\"));\n    } // Check at least one permission should be defined in each Access Boundary\n    // Rule.\n\n\n    for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules) {\n      if (rule.availablePermissions.length === 0) {\n        throw new Error('At least one permission should be defined in access boundary rules.');\n      }\n    }\n\n    this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n    this.cachedDownscopedAccessToken = null; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    this.quotaProjectId = quotaProjectId;\n  }\n  /**\n   * Provides a mechanism to inject Downscoped access tokens directly.\n   * The expiry_date field is required to facilitate determination of the token\n   * expiration which would make it easier for the token consumer to handle.\n   * @param credentials The Credentials object to set on the current client.\n   */\n\n\n  setCredentials(credentials) {\n    if (!credentials.expiry_date) {\n      throw new Error('The access token expiry_date field is missing in the provided ' + 'credentials.');\n    }\n\n    super.setCredentials(credentials);\n    this.cachedDownscopedAccessToken = credentials;\n  }\n\n  async getAccessToken() {\n    // If the cached access token is unavailable or expired, force refresh.\n    // The Downscoped access token will be returned in\n    // DownscopedAccessTokenResponse format.\n    if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {\n      await this.refreshAccessTokenAsync();\n    } // Return Downscoped access token in DownscopedAccessTokenResponse format.\n\n\n    return {\n      token: this.cachedDownscopedAccessToken.access_token,\n      expirationTime: this.cachedDownscopedAccessToken.expiry_date,\n      res: this.cachedDownscopedAccessToken.res\n    };\n  }\n  /**\n   * The main authentication interface. It takes an optional url which when\n   * present is the endpoint being accessed, and returns a Promise which\n   * resolves with authorization header fields.\n   *\n   * The result has the form:\n   * { Authorization: 'Bearer <access_token_value>' }\n   */\n\n\n  async getRequestHeaders() {\n    const accessTokenResponse = await this.getAccessToken();\n    const headers = {\n      Authorization: \"Bearer \".concat(accessTokenResponse.token)\n    };\n    return this.addSharedMetadataHeaders(headers);\n  }\n\n  request(opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(r => callback(null, r), e => {\n        return callback(e, e.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  }\n  /**\n   * Authenticates the provided HTTP request, processes it and resolves with the\n   * returned response.\n   * @param opts The HTTP request options.\n   * @param retry Whether the current attempt is a retry after a failed attempt.\n   * @return A promise that resolves with the successful response.\n   */\n\n\n  async requestAsync(opts, retry = false) {\n    let response;\n\n    try {\n      const requestHeaders = await this.getRequestHeaders();\n      opts.headers = opts.headers || {};\n\n      if (requestHeaders && requestHeaders['x-goog-user-project']) {\n        opts.headers['x-goog-user-project'] = requestHeaders['x-goog-user-project'];\n      }\n\n      if (requestHeaders && requestHeaders.Authorization) {\n        opts.headers.Authorization = requestHeaders.Authorization;\n      }\n\n      response = await this.transporter.request(opts);\n    } catch (e) {\n      const res = e.response;\n\n      if (res) {\n        const statusCode = res.status; // Retry the request for metadata if the following criteria are true:\n        // - We haven't already retried.  It only makes sense to retry once.\n        // - The response was a 401 or a 403\n        // - The request didn't send a readableStream\n        // - forceRefreshOnFailure is true\n\n        const isReadableStream = res.config.data instanceof stream.Readable;\n        const isAuthErr = statusCode === 401 || statusCode === 403;\n\n        if (!retry && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {\n          await this.refreshAccessTokenAsync();\n          return await this.requestAsync(opts, true);\n        }\n      }\n\n      throw e;\n    }\n\n    return response;\n  }\n  /**\n   * Forces token refresh, even if unexpired tokens are currently cached.\n   * GCP access tokens are retrieved from authclient object/source credential.\n   * Then GCP access tokens are exchanged for downscoped access tokens via the\n   * token exchange endpoint.\n   * @return A promise that resolves with the fresh downscoped access token.\n   */\n\n\n  async refreshAccessTokenAsync() {\n    var _a; // Retrieve GCP access token from source credential.\n\n\n    const subjectToken = (await this.authClient.getAccessToken()).token; // Construct the STS credentials options.\n\n    const stsCredentialsOptions = {\n      grantType: STS_GRANT_TYPE,\n      requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n      subjectToken: subjectToken,\n      subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n    }; // Exchange the source AuthClient access token for a Downscoped access\n    // token.\n\n    const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n    /**\n     * The STS endpoint will only return the expiration time for the downscoped\n     * access token if the original access token represents a service account.\n     * The downscoped token's expiration time will always match the source\n     * credential expiration. When no expires_in is returned, we can copy the\n     * source credential's expiration time.\n     */\n\n    const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;\n    const expiryDate = stsResponse.expires_in ? new Date().getTime() + stsResponse.expires_in * 1000 : sourceCredExpireDate; // Save response in cached access token.\n\n    this.cachedDownscopedAccessToken = {\n      access_token: stsResponse.access_token,\n      expiry_date: expiryDate,\n      res: stsResponse.res\n    }; // Save credentials.\n\n    this.credentials = {};\n    Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n    delete this.credentials.res; // Trigger tokens event to notify external listeners.\n\n    this.emit('tokens', {\n      refresh_token: null,\n      expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n      access_token: this.cachedDownscopedAccessToken.access_token,\n      token_type: 'Bearer',\n      id_token: null\n    }); // Return the cached access token.\n\n    return this.cachedDownscopedAccessToken;\n  }\n  /**\n   * Returns whether the provided credentials are expired or not.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   * @param downscopedAccessToken The credentials to check for expiration.\n   * @return Whether the credentials are expired or not.\n   */\n\n\n  isExpired(downscopedAccessToken) {\n    const now = new Date().getTime();\n    return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n  }\n\n}\n\nexports.DownscopedClient = DownscopedClient;","map":null,"metadata":{},"sourceType":"script"}