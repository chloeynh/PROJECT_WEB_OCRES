{"ast":null,"code":"\"use strict\"; // Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeCrypto = void 0;\n\nconst crypto = require(\"crypto\");\n\nclass NodeCrypto {\n  async sha256DigestBase64(str) {\n    return crypto.createHash('sha256').update(str).digest('base64');\n  }\n\n  randomBytesBase64(count) {\n    return crypto.randomBytes(count).toString('base64');\n  }\n\n  async verify(pubkey, data, signature) {\n    const verifier = crypto.createVerify('sha256');\n    verifier.update(data);\n    verifier.end();\n    return verifier.verify(pubkey, signature, 'base64');\n  }\n\n  async sign(privateKey, data) {\n    const signer = crypto.createSign('RSA-SHA256');\n    signer.update(data);\n    signer.end();\n    return signer.sign(privateKey, 'base64');\n  }\n\n  decodeBase64StringUtf8(base64) {\n    return Buffer.from(base64, 'base64').toString('utf-8');\n  }\n\n  encodeBase64StringUtf8(text) {\n    return Buffer.from(text, 'utf-8').toString('base64');\n  }\n  /**\n   * Computes the SHA-256 hash of the provided string.\n   * @param str The plain text string to hash.\n   * @return A promise that resolves with the SHA-256 hash of the provided\n   *   string in hexadecimal encoding.\n   */\n\n\n  async sha256DigestHex(str) {\n    return crypto.createHash('sha256').update(str).digest('hex');\n  }\n  /**\n   * Computes the HMAC hash of a message using the provided crypto key and the\n   * SHA-256 algorithm.\n   * @param key The secret crypto key in utf-8 or ArrayBuffer format.\n   * @param msg The plain text message.\n   * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer\n   *   format.\n   */\n\n\n  async signWithHmacSha256(key, msg) {\n    const cryptoKey = typeof key === 'string' ? key : toBuffer(key);\n    return toArrayBuffer(crypto.createHmac('sha256', cryptoKey).update(msg).digest());\n  }\n\n}\n\nexports.NodeCrypto = NodeCrypto;\n/**\n * Converts a Node.js Buffer to an ArrayBuffer.\n * https://stackoverflow.com/questions/8609289/convert-a-binary-nodejs-buffer-to-javascript-arraybuffer\n * @param buffer The Buffer input to covert.\n * @return The ArrayBuffer representation of the input.\n */\n\nfunction toArrayBuffer(buffer) {\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n/**\n * Converts an ArrayBuffer to a Node.js Buffer.\n * @param arrayBuffer The ArrayBuffer input to covert.\n * @return The Buffer representation of the input.\n */\n\n\nfunction toBuffer(arrayBuffer) {\n  return Buffer.from(arrayBuffer);\n}","map":null,"metadata":{},"sourceType":"script"}