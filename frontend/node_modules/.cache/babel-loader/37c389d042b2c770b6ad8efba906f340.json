{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"/Users/chloe/Documents/Cours/ING4/Techno Web/PROJECT_WEB_OCRES/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PageDescriptor = void 0;\n\nconst ended = require(\"is-stream-ended\");\n\nconst stream_1 = require(\"stream\");\n\nconst normalApiCaller_1 = require(\"../normalCalls/normalApiCaller\");\n\nconst pagedApiCaller_1 = require(\"./pagedApiCaller\");\n\nconst maxAttemptsEmptyResponse = 10;\n/**\n * A descriptor for methods that support pagination.\n */\n\nclass PageDescriptor {\n  constructor(requestPageTokenField, responsePageTokenField, resourceField) {\n    this.requestPageTokenField = requestPageTokenField;\n    this.responsePageTokenField = responsePageTokenField;\n    this.resourceField = resourceField;\n  }\n  /**\n   * Creates a new object Stream which emits the resource on 'data' event.\n   */\n\n\n  createStream(apiCall, request, options) {\n    const stream = new stream_1.PassThrough({\n      objectMode: true\n    });\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const maxResults = 'maxResults' in options ? options.maxResults : -1;\n    let pushCount = 0;\n    let started = false;\n\n    function callback(err, resources, next, apiResp) {\n      if (err) {\n        stream.emit('error', err);\n        return;\n      } // emit full api response with every page.\n\n\n      stream.emit('response', apiResp);\n\n      for (let i = 0; i < resources.length; ++i) {\n        if (ended(stream)) {\n          return;\n        }\n\n        if (resources[i] === null) {\n          continue;\n        }\n\n        stream.push(resources[i]);\n        pushCount++;\n\n        if (pushCount === maxResults) {\n          stream.end();\n        }\n      }\n\n      if (ended(stream)) {\n        return;\n      }\n\n      if (!next) {\n        stream.end();\n        return;\n      } // When pageToken is specified in the original options, it will overwrite\n      // the page token field in the next request. Therefore it must be cleared.\n\n\n      if ('pageToken' in options) {\n        delete options.pageToken;\n      }\n\n      if (stream.isPaused()) {\n        request = next;\n        started = false;\n      } else {\n        setImmediate(apiCall, next, options, callback);\n      }\n    }\n\n    stream.on('resume', () => {\n      if (!started) {\n        started = true;\n        apiCall(request, options, callback);\n      }\n    });\n    return stream;\n  }\n  /**\n   * Create an async iterable which can be recursively called for data on-demand.\n   */\n\n\n  asyncIterate(apiCall, request, options) {\n    options = Object.assign({}, options, {\n      autoPaginate: false\n    });\n    const iterable = this.createIterator(apiCall, request, options);\n    return iterable;\n  }\n\n  createIterator(apiCall, request, options) {\n    const asyncIterable = {\n      [Symbol.asyncIterator]() {\n        let nextPageRequest = request;\n        const cache = [];\n        return {\n          async next() {\n            if (cache.length > 0) {\n              return Promise.resolve({\n                done: false,\n                value: cache.shift()\n              });\n            }\n\n            let attempts = 0;\n\n            while (cache.length === 0 && nextPageRequest) {\n              let result;\n\n              var _ref = await apiCall(nextPageRequest, options);\n\n              var _ref2 = _slicedToArray(_ref, 2);\n\n              result = _ref2[0];\n              nextPageRequest = _ref2[1];\n\n              // For pagination response with protobuf map type, use tuple as representation.\n              if (result && !Array.isArray(result)) {\n                for (const _ref3 of Object.entries(result)) {\n                  var _ref4 = _slicedToArray(_ref3, 2);\n\n                  const key = _ref4[0];\n                  const value = _ref4[1];\n                  cache.push([key, value]);\n                }\n              } else {\n                cache.push(...result);\n              }\n\n              if (cache.length === 0) {\n                ++attempts;\n\n                if (attempts > maxAttemptsEmptyResponse) {\n                  break;\n                }\n              }\n            }\n\n            if (cache.length === 0) {\n              return Promise.resolve({\n                done: true,\n                value: undefined\n              });\n            }\n\n            return Promise.resolve({\n              done: false,\n              value: cache.shift()\n            });\n          }\n\n        };\n      }\n\n    };\n    return asyncIterable;\n  }\n\n  getApiCaller(settings) {\n    if (!settings.autoPaginate) {\n      return new normalApiCaller_1.NormalApiCaller();\n    }\n\n    return new pagedApiCaller_1.PagedApiCaller(this);\n  }\n\n}\n\nexports.PageDescriptor = PageDescriptor;","map":null,"metadata":{},"sourceType":"script"}